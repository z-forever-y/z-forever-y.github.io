{"meta":{"title":"Hexo","subtitle":"","description":"","author":"John Doe","url":"http://example.com","root":"/"},"pages":[],"posts":[{"title":"第一篇博客","slug":"第一篇博客","date":"2022-11-17T10:46:58.000Z","updated":"2022-11-17T10:57:39.325Z","comments":true,"path":"2022/11/17/第一篇博客/","link":"","permalink":"http://example.com/2022/11/17/%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2/","excerpt":"","text":"1.作用域 作用域 (Scope) 的概念：变量和函数的可访问范围，控制着变量和函数的 可见性 和 生命周期 1234# 1.全局作用域// 直接写在script或者单独的JS文件中，属于全局作用域可见性：全局作用域中声明的变量，在代码的任何地方都可以访问到生命周期： 伴随着页面的生命周期 （页面关闭就销毁了） 1234# 2. 局部作用域 （函数作用域）// 变量只能在函数内部访问，外部无法访问可见性：函数外部不能访问函数内部的变量生命周期：变量在函数调用执行后，就会被销毁/清空/回收 1234567# 3.块级作用域// 使用 let 或者 const 声明的变量，在 &#123;&#125; 中会形成块级作用域，&#123;&#125;包裹起来的叫代码块特点：1.只有let,const 声明的会产生块级作用域 &#123;&#125;2.块级作用域的外部不能访问内部的变量3.两个块级作用域中&#x27;相同名称&#x27;的变量不会相互影响4.if/for 是语句，但是用let/const声明的变量，会在内部形成块级作用域 12# Scope1. Local 局部作用域 2.Global 全局作用域 3.Closure 闭包 4.Block 块级作用域 2.为什么需要新增块级作用域1234567891011121314151617181920212223242526 var temp = new Date() function fn() &#123; console.log(temp) if (false) &#123; // if是语句 var temp = &#x27;hello world&#x27; &#125; &#125; fn() 打印出的值是 undefined 解释： 1. var 声明的变量会提升到当前作用域的最前面 2. if是语句，不是函数，var声明的变量不能形成作用域 3. var 声明的变量，只提升声明，不赋值 ，默认是undefined 总结：1.内层变量可能覆盖外层变量 2. var声明的变量，在for循环中，提升到全局 // var i for (var i = 0; i &lt;= 3; i++) &#123; console.log(i) &#125; // 最后循环完，i++， i变为4 console.log(i) 总结：用来计数的循环变量i,会泄露为全局变量 3. var let const 的区别？1234561.只有 let/const 可以形成块级作用域2.let/const 不允许变量提升，var可以3.let/const 不允许重复声明，var可以4.let/const 存在暂时性死区(temporal dead zone) TDZ，不能再声明之前使用5.浏览器中，var声明的全局变量会挂载到window对象上 不建议使用 var声明name这个名字，因为window本身有name这个属性，会改变原始的值 4. const 关键字121. const 一旦声明，必须马上赋值2. const 声明的变量不能改变值 （简单类型不能改变值，引用类型不能改变地址） 5.作用域链12345678910111213141516// 全局作用域 let a = 3 let b = 1 function f() &#123; // 局部作用域 let a = 1 function g() &#123; // 局部作用域 a = 2 console.log(a) &#125; g() // 调用g &#125; f() // 调用f输出结果：2 5.1 什么是作用域链？ ​ 函数是可以嵌套函数的，每个函数都有一个局部作用域，这样子就形成了作用域的嵌套 ​ 当访问内层作用域中的某个变量的时候，首先在当前作用域中查找这个变量，如果不存在，往上层查找，直到找到全局作用域 5.2 作用域链的本质：底层的变量查找机制 5.3 查找规则：1.优先在当前作用域中查找变量 2，如果不存在，往上层作用域中查找变量，直到全局作用域 6.垃圾回收机制12341. 什么是垃圾回收机制？ 垃圾回收机制 （garbage collection）简称GC，JS中内存的分配和回收是自动完成的，内存在不使用的时候就会被JS引擎/垃圾回收程序自动回收2.什么是内存泄漏? 不再使用的内存，没有及时释放掉 7.垃圾回收机制策略123456789101112131415161718191. 引用计数法 （淘汰） （1）跟踪记录每一个值被引用的次数 （2）如果这个值被引用了一次，那么就记录次数1 （3）多次引用会累加 （4）如果减少一个引用就减少1 （5）如果引用次数是0， 则释放内存 什么时候引用次数为0了，直接回收 缺陷：循环引用的时候，堆内存空间中创建的对象相互引用，计数永远不会为0，这个对象会一直占用着内存空间，造成内存泄露 2.标记清除算法 主要将GC的过程分为两个阶段 （1）标记阶段：标记空间中的活动对象和非活动对象 从一组根元素开始。在这个遍历过程中，能访问到的元素称为活动对象，不能访问的可以判断为垃圾数据 （2）清除阶段：回收非活动对象，也就是销毁非活动对象 // 缺陷：内存碎片化 ==&gt; 标记整理算法： 1.标记空间中活动对象和非活动对象 2.回收非活动对象所占用的内存 3.内存整理 8.闭包1234567891011121314function outer()&#123; const a=10 function fn()&#123; console.log(a); &#125; fn() &#125; outer()1.什么是闭包？ 定义：内层函数引用外层函数的变量的集合 闭包 = 内层函数 + 外层函数的变量2.条件： （1）首先必须要有内层函数 （2）内层函数使用了外层函数的变量 9.闭包的作用123456789101112131415161718192021222324252627282930313233 function outer()&#123; let a = 10 &#125; outer() console.log(a) 外部作用域不能访问内层作用域中的变量 # 闭包的作用:# 1.让外部可以访问内部函数的变量 function outer() &#123; let a = 10 function fn() &#123; console.log(a); &#125; // fn() return fn &#125;const fun = outer() fun() 我们在外部调用fun的时候，相当于执行上面注释的函数,执行到log（a）,找的是outer函数内部的变量a # 2.实现数据的私有化（我们在外面是无法修改里面变量的值的） function count()&#123; let i=0 return function()&#123; i++ console.log(`调用了$&#123;i&#125;次`); &#125; &#125; const fn=count() fn() 10.闭包产生的问题：内存泄漏12345678910111213 function count() &#123; let i = 0 return function () &#123; i++ console.log(`调用了$&#123;i&#125;次`) &#125; &#125; const fn = count() fn()标记清除法： 从一组根元素开始，或者说从全局作用域出发，找到这个 i 变量，能访问到这个i变量，把它标记为活动对象，所以就不会被GC程序清理掉本来，我们调用fn()后，按理说，i是函数count里面的变量，局部变量，执行完后应该销毁但是现在，因为i变量和内部的函数function形成了闭包，i变量没有被销毁，所以就造成了内存泄漏 11.变量的提升1231.所有var声明的变量在执行之前，会提升到当前作用域的最前面2.var 声明的变量，只提升声明，不提升赋值3.var 声明的变量，如果不赋值，默认是undefined 12.函数的提升123456789101112131415161718函数的声明有两种方式：// 声明式 fn() function fn() &#123; console.log(666) &#125; // 表达式 const foo = function () &#123; console.log(888) &#125; var bar = function () &#123; console.log(999) &#125;1.会把用function声明的函数，提升到当前作用域的最前面2.表达式的情况，如果是用var声明的函数，只提升声明，不提升赋值 13 arguments对象12345678910111213 function getSum()&#123; let sum=0 //不能用foerach进行遍历，因为他是一个伪数组，没有foreach for (let i=0; i&lt;arguments.length; i++)&#123; sum+=arguments[i] &#125; return sum &#125; const res=getSum(2,3,4,5,6) console.log(res);1.除箭头函数以外，所有的函数都内置了（默认就是存在，自带的）一个arguments对象2. arguments 伪数组 接收了我们传递过来的实参 3.arguments对象，只存在于函数中 14.剩余参数123456789101112// 求所有传入参数的和 const getSum =(...arr) =&gt;&#123; let sum=0 arr.forEach(el =&gt; sum+=el) return sum &#125; const res=getSum(1,2,3) console.log(res);剩余参数 rest形式 ...变量名 变量名自定义1.剩余参数res 是一个真数组，存的是剩余参数2.只能放在参数的最后一位 15.扩展运算符 spread1.扩展运算符 （Spread）是三个点（…） 2.他是res(剩余参数)的逆运算 3.作用：将一个数组转为用逗号分隔的参数序列 注意：他不会改变原数组 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051# 主要应用// 1.求一个数组的最大最小值 const arr2=[11,1,6,9,77] // Math.max() 它本身接收的是参数列表 console.log(Math.max(11,1,6,9,77)); // ..arr2 ==&gt; 11,1,6,9,77 console.log(Math.max(...arr2)); console.log(Math.min(...arr2));// 2.复制/拷贝数组 （浅拷贝） const a1=[1,2] const a2=a1 // 赋值，数组的直接赋值，赋的是地址，指向的是堆内存中同一个数组对象 a2[0]=666 console.log(a1);/*========================= start ===========================*/ const a3=[5,6,7] const a4=[...a3] // ==&gt;[5,6,7] a3[0]=9 console.log(a4); // [5,6,7] // ==&gt; 数组里面的元素是基本数组类型， 修改数组元素的值，相互不影响 // 3. 合并数组 (浅拷贝) const a5 = [&#x27;c&#x27;, &#x27;d&#x27;] const a6 = [&#x27;e&#x27;, &#x27;f&#x27;] // ES5 的合并 concat const resArr = a5.concat(a6) console.log(resArr) // ES6 ... const a7 = [...a5, ...a6] console.log(a7) // 4.将字符串转成数组 [...str] ==&gt;将字符串展开成数组 const str=&#x27;hello word&#x27; const a8=[...str] console.log(a8); const res=str.split(&#x27;&#x27;).reverse.join(&#x27;&#x27;) // ==&gt; 扩展运算符的方式 const resStr = [...str].reverse().join(&#x27;&#x27;) console.log(resStr); // 5. 将伪数组转为真数组 const divs = document.querySelectorAll(&#x27;div&#x27;) const resDiv = [...divs] console.log(resDiv) resDiv.push(666) console.log(resDiv) 16.将伪数组转换成真数组的两种方式12345// 1. [...likeArr] 使用扩展运算符// 2. Array.from(likeArr) const resReal = Array.from(divs) console.log(resReal)","categories":[],"tags":[]},{"title":"Hello World","slug":"hello-world","date":"2022-11-17T10:42:47.157Z","updated":"2022-11-17T10:42:47.157Z","comments":true,"path":"2022/11/17/hello-world/","link":"","permalink":"http://example.com/2022/11/17/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}],"categories":[],"tags":[]}